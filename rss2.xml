<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Suncio&#39;s Blog</title>
    <link>https://suncio.me/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 07 Oct 2020 03:18:33 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Physical Simulation: Smoothed Particle Hydrodynamics</title>
      <link>https://suncio.me/2020/10/06/Physical-Simulation-Smoothed-Particle-Hydrodynamics/</link>
      <guid>https://suncio.me/2020/10/06/Physical-Simulation-Smoothed-Particle-Hydrodynamics/</guid>
      <pubDate>Wed, 07 Oct 2020 03:02:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h5 id=&quot;Lagrange-fluid-simulation-Smoothed-particle-hydrodynamics&quot;&gt;&lt;a href=&quot;#Lagrange-fluid-simulation-Smoothed-particle-hydrodynamics&quot; clas
        
      
      </description>
      
      <content:encoded><![CDATA[<h5 id="Lagrange-fluid-simulation-Smoothed-particle-hydrodynamics"><a href="#Lagrange-fluid-simulation-Smoothed-particle-hydrodynamics" class="headerlink" title="Lagrange fluid simulation: Smoothed particle hydrodynamics"></a>Lagrange fluid simulation: Smoothed particle hydrodynamics</h5><p><strong>High-level idea:</strong> use particle carrying samples of physical quantities, and a kernel function $W$, to approximate continuous fields:</p><script type="math/tex; mode=display">A(\textbf{x}) = \sum_{i}{A_i\frac{m_i}{\rho_i}W\left( ||\textbf{x} - \textbf{x}_j||_2, h \right)}</script><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/80/SPHInterpolationColorsVerbose.svg/440px-SPHInterpolationColorsVerbose.svg.png" alt="SPH particles and their kernel"></p><ul><li>Originally proposed for astrophysical problems</li><li>No meshes. Very suitable for free-surface flows!</li><li>Easy to understand intuitively: just imagine each particle is a small parcel of water (although strictly not the case)</li></ul><p><strong>Implementing SPH using the Equation of States (EOS)</strong></p><p>Also know as Weakly Compressible SPH (WCSPH).</p><p>Momentum equation: ($\rho$: density; $B$: bulk modulus; $\gamma$: constant, usually $\sim 7$ )</p><script type="math/tex; mode=display">\frac{D\textbf{v}}{Dt} = -\frac{1}{\rho} \nabla p + \textbf{g},\ \ \ p = B\left( \left( \frac{\rho}{\rho_0} \right)^{\gamma} - 1 \right)\\\ \\\\\A(\textbf{x}) = \sum_{i}{A_i\frac{m_i}{\rho_i}W\left( ||\textbf{x} - \textbf{x}_j||_2, h \right)},\ \ \ \rho_i= \sum_j{ m_j W \left( ||\textbf{x} - \textbf{x}_j||_2, h \right)}</script><p><strong>Gradients in SPH</strong></p><script type="math/tex; mode=display">A(\textbf{x}) = \sum_{i}{A_i\frac{m_i}{\rho_i}W\left( ||\textbf{x} - \textbf{x}_j||_2, h \right)}\\\\\\nabla A_i = \rho_i \sum_{j} m_j \left( \frac{A_i}{\rho_i^2} + \frac{A_j}{\rho_j^2} \right) \nabla_{\textbf{x}_i} W\left( ||\textbf{x} - \textbf{x}_j||_2, h \right)</script><ul><li>Not really accurate</li><li>But at least symmetric and momentum conversing</li></ul><p>Now we can compute $\nabla p_i$</p><p><strong>SPH Simulation Cycle</strong></p><ol><li><p>For each particle $i$, compute $\rho_i= \sum_j{ m_j W \left( ||\textbf{x} - \textbf{x}_j||_2, h \right)}$</p></li><li><p>For each particle $i$, compute $\nabla p_i$ using the gradient operator</p></li><li><p>Symplectic Euler step:</p><script type="math/tex; mode=display">\textbf{v}_{t+1} = \textbf{v}_t + \Delta t \frac{D\textbf{v}}{Dt}\\\textbf{x}_{t+1} = \textbf{x}_t + \Delta t \textbf{v}_{t+1}\</script></li></ol><p><strong>Variants of SPH</strong></p><p><strong>Courant-Friedrichs-Lewy (CFL) condition</strong></p><p>One upper bound of time step size:</p><script type="math/tex; mode=display">C = \frac{u \Delta t}{\Delta x} \le C_{max} \sim 1</script><ul><li>$C$: CFL number (Courant number, or simple the CFL)</li><li>$\Delta t$: time step</li><li>$\Delta x$: length interval (e.g. particle radius and grid size)</li><li>$u$: maximum (velocity)</li></ul><p>Application: estimating allowed time step in (explicit) time integrations. Typical $C_{max}$ in graphics:</p><ul><li>SPH: ~ 0.4</li><li>MPM: 0.3 ~ 1</li><li>FLIP fluid (smoke): 1 ~ 5+</li></ul><p><strong>Accelerating SPH: Neighborhood search</strong></p><p>So far, per sub-step complexity of SPH is $O(n^2)$. This is too costly to be practical. In practice, people build spatial data structure such as voxel grid to accelerate neighborhood search. This reduces time complexity to $O(n)$.</p><p>Reference: <a href="https://github.com/InteractiveComputerGraphics/CompactNSearch" target="_blank" rel="external">Compact Hashing</a></p><p><strong>Extend reading</strong></p><p>SPH Fluids in Computer Graphics: <a href="https://cg.informatik.uni-freiburg.de/publications/2014_EG_SPH_STAR.pdf" target="_blank" rel="external">https://cg.informatik.uni-freiburg.de/publications/2014_EG_SPH_STAR.pdf</a></p><p>A tutorial for SPH: <a href="https://interactivecomputergraphics.github.io/SPH-Tutorial/" target="_blank" rel="external">Smoothed Particle Hydrodynamics Techniques for the Physics Based Simulation of Fluids and Solids</a></p>]]></content:encoded>
      
      <comments>https://suncio.me/2020/10/06/Physical-Simulation-Smoothed-Particle-Hydrodynamics/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Physical Simulation: Mass-Spring Systems</title>
      <link>https://suncio.me/2020/10/05/Physical-Simulation-Mass-Spring-Systems/</link>
      <guid>https://suncio.me/2020/10/05/Physical-Simulation-Mass-Spring-Systems/</guid>
      <pubDate>Tue, 06 Oct 2020 02:58:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;This a learning note from the &lt;a href=&quot;https://forum.taichi.graphics/t/topic/272&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;class&lt;/a&gt; given by Yuanm
        
      
      </description>
      
      <content:encoded><![CDATA[<p>This a learning note from the <a href="https://forum.taichi.graphics/t/topic/272" target="_blank" rel="external">class</a> given by Yuanming Hu about <strong>Physical Simulation</strong></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>Two Views of Continuums</strong></p><p>There are two basic methods for solving fluid equations</p><ul><li><p>Lagrangian View: “What are my position and velocity?” </p><p>- Method based on particles</p><p><img src="/images/lagrange.gif" alt="lagrange view"></p></li><li><p>Eulerian View: “What is the material velocity passing by?” </p><p>- Method based on grid</p><p><img src="/images/eulerian.gif" alt="eulerian view"></p></li></ul><h2 id="Mass-Spring-Systems"><a href="#Mass-Spring-Systems" class="headerlink" title="Mass-Spring Systems"></a>Mass-Spring Systems</h2><p>Mass Spring Systems are a physical simulation based on Lagrangian view, an object are seen as  . Mass-spring systems are good for  </p><p><strong>Hooke’s Law</strong></p><script type="math/tex; mode=display">\textbf{f}_{ij} = -k(||\textbf{x}_i - \textbf{x}_j||_2-l_{ij})(\widehat{\textbf{x}_i-\textbf{x}_j})\\\ \\\textbf{f}_i = \sum_{j}^{j \ne i}{\textbf{f}_{ij}}</script><p><strong>Newton’s second law of motion</strong></p><script type="math/tex; mode=display">\frac{\partial \textbf{v}_i}{\partial t} = \frac{1}{m}\textbf{f}_i\\\ \\\frac{\partial \textbf{x}_i}{\partial t} = \textbf{v}_i</script><h2 id="Time-integration"><a href="#Time-integration" class="headerlink" title="Time integration"></a>Time integration</h2><p><strong>Time integration - Explicit</strong></p><p>(1) Forward Euler (explicit)</p><script type="math/tex; mode=display">\textbf{v}_{t+1} = \textbf{v}_t + \Delta t \frac{\textbf{f}_t}{m}\\\textbf{x}_{t+1} = \textbf{x}_t + \Delta t \textbf{v}_t</script><p>(2) Semi implicit Euler (aka. symplectic Euler, explicit)</p><script type="math/tex; mode=display">\textbf{v}_{t+1} = \textbf{v}_t + \Delta t \frac{\textbf{f}_t}{m}\\\textbf{x}_{t+1} = \textbf{x}_t + \Delta t \textbf{v}_{t+1}</script><div class="table-container"><table><thead><tr><th>Pros</th><th>Cons</th></tr></thead><tbody><tr><td>Future depends only on past</td><td>Easy to explode</td></tr><tr><td>Easy to implement</td><td>Bad for stiff materials</td></tr></tbody></table></div><p>Explosion limit:</p><script type="math/tex; mode=display">\Delta t \le c \sqrt{\frac{m}{k}} (c \sim 1)</script><p><strong>Time integration - Implicit</strong></p><p>Backward Euler (often with Newton’s method, implicit)</p><script type="math/tex; mode=display">\textbf{x}_{t+1} = \textbf{x}_t + \Delta t \textbf{v}_{t+1}\\\textbf{v}_{t+1} = \textbf{v}_t + \Delta t \textbf{M}^{-1}\textbf{f}(\textbf{x}_{t+1})</script><p>Estimate $\textbf{x}_{t+1}$:</p><script type="math/tex; mode=display">\textbf{v}_{t+1} = \textbf{v}_t + \Delta t \textbf{M}^{-1}\textbf{f}(\textbf{x}_{t} + \Delta t \textbf{v}_{t+1})</script><p>Linearize (one step of Newton’s method):</p><script type="math/tex; mode=display">\textbf{v}_{t+1} = \textbf{v}_t + \Delta t \textbf{M}^{-1}    \left[\textbf{f}(\textbf{x}_{t}) + \frac{\partial \textbf{f}}{\partial \textbf{x}} (\textbf{x}_{t}) \Delta t \textbf{v}_{t+1}    \right]</script><p>Clean up:</p><script type="math/tex; mode=display">\left[\textbf{I} - \Delta t^2 \textbf{M}^{-1} \frac{\partial \textbf{f}}{\partial \textbf{x}} (\textbf{x}_{t})     \right] \textbf{v}_{t+1} = \textbf{v}_t + \Delta t \textbf{M}^{-1}\textbf{f}(\textbf{x}_{t})</script><p>How to solve it</p><ul><li>Jacobi/Gauss-Seidel iterations (easy to implement)</li><li>Conjugate gradients </li></ul><p><strong>Unify explicit and implicit integrators</strong></p><script type="math/tex; mode=display">\left[\textbf{I} - \beta \Delta t^2 \textbf{M}^{-1} \frac{\partial \textbf{f}}{\partial \textbf{x}} (\textbf{x}_{t})   \right] \textbf{v}_{t+1} = \textbf{v}_t + \Delta t \textbf{M}^{-1}\textbf{f}(\textbf{x}_{t})</script><ul><li>$\beta = 0$: forward/semi-implicit Euler (explicit)</li><li>$\beta = 1/2$: middle-point (implicit)</li><li>$\beta = 1$: backward Euler (implicit)</li></ul><p><strong>Solve faster</strong></p><ul><li>Sparse matrices</li><li>Conjugate gradients</li><li>Preconditioning</li></ul>]]></content:encoded>
      
      <comments>https://suncio.me/2020/10/05/Physical-Simulation-Mass-Spring-Systems/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Important Statement</title>
      <link>https://suncio.me/2020/10/01/Important-Statement/</link>
      <guid>https://suncio.me/2020/10/01/Important-Statement/</guid>
      <pubDate>Fri, 02 Oct 2020 05:47:51 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;This blog is currently being reorganized. My recent projects and study notes will be posted to github/suncio repositories.&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<p>This blog is currently being reorganized. My recent projects and study notes will be posted to github/suncio repositories.</p>]]></content:encoded>
      
      <comments>https://suncio.me/2020/10/01/Important-Statement/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Ruskell &amp; Algorithms (2) -- FFT</title>
      <link>https://suncio.me/2017/12/09/Ruskell-Algorithms-2-FFT/</link>
      <guid>https://suncio.me/2017/12/09/Ruskell-Algorithms-2-FFT/</guid>
      <pubDate>Sun, 10 Dec 2017 07:27:43 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;这是一个利用Rust&amp;amp;Haskell实现算法导论上的经典算法或其他有趣算法的系列，代码可以点击此&lt;a href=&quot;https://play.rust-lang.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线运行&lt;/a&gt;得到结果，你可能
        
      
      </description>
      
      <content:encoded><![CDATA[<p>这是一个利用Rust&amp;Haskell实现算法导论上的经典算法或其他有趣算法的系列，代码可以点击此<a href="https://play.rust-lang.org/" target="_blank" rel="external">在线运行</a>得到结果，你可能需要补充合理的输入输出与main函数。<br>第二篇是实现FFT与普通多项式乘法，下面是相应的Rust代码：</p><p>首先是FFT算法<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dft</span></span>(src: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;Complex&lt;<span class="built_in">f64</span>&gt;&gt;, flag: <span class="built_in">bool</span>) &#123;</div><div class="line"><span class="comment">// src 的长度为 2 的幂； flag 为 false 时计算 DFT， 为 true 时计算逆 DFT</span></div><div class="line"><span class="keyword">let</span> len = src.len();</div><div class="line"><span class="keyword">let</span> s = len.trailing_zeros();</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..len &#123;</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> k = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..s &#123;</div><div class="line">k |= ((i &gt;&gt; j) &amp; <span class="number">1</span>) &lt;&lt; (s - <span class="number">1</span> - j);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> i &lt; k &#123;</div><div class="line">src.swap(i, k);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..s &#123;</div><div class="line"><span class="keyword">let</span> base = (<span class="number">2</span> &lt;&lt; i) <span class="keyword">as</span> <span class="built_in">usize</span>;</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> j = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> j &lt; len &#123;</div><div class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">0</span>..(base / <span class="number">2</span>) &#123;</div><div class="line"><span class="keyword">let</span> w = <span class="keyword">if</span> flag &#123;</div><div class="line">Complex::from_polar(&amp;<span class="number">1.0</span>, &amp;(-<span class="number">2.0</span> * <span class="built_in">f64</span>::consts::PI * k <span class="keyword">as</span> <span class="built_in">f64</span> / base <span class="keyword">as</span> <span class="built_in">f64</span>))</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">Complex::from_polar(&amp;<span class="number">1.0</span>, &amp;(<span class="number">2.0</span> * <span class="built_in">f64</span>::consts::PI * k <span class="keyword">as</span> <span class="built_in">f64</span> / base <span class="keyword">as</span> <span class="built_in">f64</span>))</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> t = w * src[base / <span class="number">2</span> + j + k];</div><div class="line"><span class="keyword">let</span> u = src[j + k];</div><div class="line">src[j + k] = u + t;</div><div class="line">src[base / <span class="number">2</span> + j + k] = u - t;</div><div class="line">&#125;</div><div class="line">j += base;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> flag &#123;</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..len &#123;</div><div class="line">src[i] = src[i] / len <span class="keyword">as</span> <span class="built_in">f64</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">poly_mult_fft</span></span>(a: &amp;[<span class="built_in">f64</span>], b: &amp;[<span class="built_in">f64</span>]) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">f64</span>&gt; &#123;</div><div class="line"><span class="keyword">let</span> len = <span class="number">1</span> &lt;&lt; (<span class="number">32</span> - ((a.len() + b.len()) <span class="keyword">as</span> <span class="built_in">i32</span>).leading_zeros());</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> aa: <span class="built_in">Vec</span>&lt;Complex&lt;<span class="built_in">f64</span>&gt;&gt; = <span class="built_in">vec!</span>[Complex &#123;re: <span class="number">0.0</span>, im: <span class="number">0.0</span>&#125;; len];</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..a.len() &#123;</div><div class="line">aa[i].re = a[i];</div><div class="line">&#125;</div><div class="line">dft(&amp;<span class="keyword">mut</span> aa, <span class="literal">false</span>);</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> bb: <span class="built_in">Vec</span>&lt;Complex&lt;<span class="built_in">f64</span>&gt;&gt; = <span class="built_in">vec!</span>[Complex &#123;re: <span class="number">0.0</span>, im: <span class="number">0.0</span>&#125;; len];</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..b.len() &#123;</div><div class="line">bb[i].re = b[i];</div><div class="line">&#125;</div><div class="line">dft(&amp;<span class="keyword">mut</span> bb, <span class="literal">false</span>);</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..len &#123;</div><div class="line">aa[i] *= bb[i];</div><div class="line">&#125;</div><div class="line">dft(&amp;<span class="keyword">mut</span> aa, <span class="literal">true</span>);</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> c = <span class="built_in">Vec</span>::new();</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..(a.len() + b.len() - <span class="number">1</span>) &#123;</div><div class="line">c.push(aa[i].re);</div><div class="line">&#125;</div><div class="line">c</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后是普通乘法<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">poly_mult_norm</span></span>(a: &amp;[<span class="built_in">f64</span>], b: &amp;[<span class="built_in">f64</span>]) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">f64</span>&gt; &#123;</div><div class="line"><span class="keyword">let</span> al = a.len();</div><div class="line"><span class="keyword">let</span> bl = b.len();</div><div class="line"><span class="keyword">let</span> cl = al + bl - <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> c = <span class="built_in">vec!</span>[<span class="number">0.0</span>; cl];</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..cl &#123;</div><div class="line"><span class="keyword">let</span> k = <span class="keyword">if</span> i + <span class="number">1</span> &lt; bl &#123; <span class="number">0</span> &#125; <span class="keyword">else</span> &#123; i + <span class="number">1</span> - bl &#125;;</div><div class="line"><span class="keyword">let</span> m = <span class="keyword">if</span> i + <span class="number">1</span> &gt; al &#123; al &#125; <span class="keyword">else</span> &#123; i + <span class="number">1</span> &#125;;</div><div class="line"><span class="keyword">for</span> j <span class="keyword">in</span> k..m &#123;</div><div class="line">c[i] += a[j] * b[i - j];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">c</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Note:</p><ol><li>需要<code>extern crate num</code>使用复数</li><li>FFT需要大约2000+的输入量才能发挥其数量级优势，否则被常数拖死，还没有普通乘法快</li></ol>]]></content:encoded>
      
      <comments>https://suncio.me/2017/12/09/Ruskell-Algorithms-2-FFT/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Ruskell &amp; Algorithms (1) -- Matrix Chain Order</title>
      <link>https://suncio.me/2017/11/29/Ruskell-Algorithms-1-Matrix-Chain-Order/</link>
      <guid>https://suncio.me/2017/11/29/Ruskell-Algorithms-1-Matrix-Chain-Order/</guid>
      <pubDate>Wed, 29 Nov 2017 18:10:12 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;这是一个利用Rust&amp;amp;Haskell实现算法导论上的经典算法或其他有趣算法的系列（大概不会坑吧），所有代码可以点击此&lt;a href=&quot;https://play.rust-lang.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线运行&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<p>这是一个利用Rust&amp;Haskell实现算法导论上的经典算法或其他有趣算法的系列（大概不会坑吧），所有代码可以点击此<a href="https://play.rust-lang.org/" target="_blank" rel="external">在线运行</a>得到结果。<br>第一篇是实现的利用动态规划解决矩阵链乘法问题的问题，下面是相应的Rust代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> time;</div><div class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> rand;</div><div class="line"></div><div class="line"><span class="keyword">use</span> time::*;</div><div class="line"><span class="keyword">use</span> std::vec;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_optimal_parens</span></span>(<span class="comment">/*file:&amp;mut File, */</span>s:&amp;<span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;&gt;, i:<span class="built_in">u32</span>, j:<span class="built_in">u32</span> ) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> i == j</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">print!</span>(<span class="string">"A&#123;&#125; "</span>, i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">print!</span>(<span class="string">"( "</span>);</div><div class="line">        print_optimal_parens(s, i, s[i <span class="keyword">as</span> <span class="built_in">usize</span>][j <span class="keyword">as</span> <span class="built_in">usize</span>]);</div><div class="line">        print_optimal_parens(s, s[i <span class="keyword">as</span> <span class="built_in">usize</span>][j <span class="keyword">as</span> <span class="built_in">usize</span>]+<span class="number">1</span>, j);</div><div class="line">        <span class="built_in">print!</span>(<span class="string">") "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">matrix_chain_order</span></span>(p:&amp;<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;) -&gt; (<span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;&gt;, <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;&gt;)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> n = p.len() - <span class="number">1</span>;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> m:<span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;&gt; = <span class="built_in">Vec</span>::with_capacity(n+<span class="number">1</span>);</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s:<span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;&gt; = <span class="built_in">Vec</span>::with_capacity(n+<span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..n+<span class="number">1</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> temp:<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">Vec</span>::with_capacity(n+<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n+<span class="number">1</span></div><div class="line">        &#123;</div><div class="line">            temp.push(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        m.push(temp);</div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> temp:<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">Vec</span>::with_capacity(n+<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n+<span class="number">1</span></div><div class="line">        &#123;</div><div class="line">            temp.push(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        s.push(temp);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="number">2</span>..n+<span class="number">1</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..n-l+<span class="number">2</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">let</span> j:<span class="built_in">usize</span> = i+l-<span class="number">1</span>;</div><div class="line">            m[i][j] = std::<span class="built_in">u32</span>::MAX;</div><div class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> i..j</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">let</span> temp:<span class="built_in">u32</span> = p[i-<span class="number">1</span>]* p[k] * p[j];</div><div class="line">                <span class="keyword">let</span> q:<span class="built_in">u32</span> = m[i][k] + m[k+<span class="number">1</span>][j] + temp;</div><div class="line">                <span class="keyword">if</span> q &lt; m[i][j]</div><div class="line">                &#123;</div><div class="line">                    m[i][j] = q;</div><div class="line">                    s[i][j] = k <span class="keyword">as</span> <span class="built_in">u32</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (s, m)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> vec = <span class="built_in">Vec</span>::new();</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">31</span> <span class="comment">//generate n+1 (n=30) numbers</span></div><div class="line">    &#123;</div><div class="line">        vec.push(rand::random::&lt;<span class="built_in">u32</span>&gt;() % <span class="number">100</span> + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> start = time::now();</div><div class="line">    <span class="keyword">let</span> (s, m) = matrix_chain_order(&amp;vec);</div><div class="line">    </div><div class="line">    <span class="built_in">println!</span>(<span class="string">"s:"</span>);</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..s.len()</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..s[i].len()</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">print!</span>(<span class="string">"&#123;&#125;  "</span>, s[i][j]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">println!</span>(<span class="string">"  new line "</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"m:"</span>);</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..m.len()</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..m[i].len()</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">print!</span>(<span class="string">"&#123;&#125;  "</span>, m[i][j]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">println!</span>(<span class="string">"  new line  "</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">let</span> end = time::now();</div><div class="line"><span class="keyword">let</span> dura = end - start; </div><div class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, dura);  </div><div class="line">    print_optimal_parens(&amp;s, <span class="number">1</span>, s.len() <span class="keyword">as</span> <span class="built_in">u32</span> - <span class="number">1</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Note:</p><ol><li>有一个小坑是关于time的，似乎是由于实现原因，不能用占位符{}打印time，需要用debug下的{:?}来打印时间。</li><li>Rust的变量生存周期跟c系列还是挺不一样的，写的时候略微有些不习惯</li></ol>]]></content:encoded>
      
      <comments>https://suncio.me/2017/11/29/Ruskell-Algorithms-1-Matrix-Chain-Order/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
