<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Suncio&#39;s Blog</title>
    <link>https://suncio.me/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Thu, 15 Oct 2020 07:20:28 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Real Time Collision Detection: Intro</title>
      <link>https://suncio.me/2020/10/16/Real-Time-Collision-Detection-Intro/</link>
      <guid>https://suncio.me/2020/10/16/Real-Time-Collision-Detection-Intro/</guid>
      <pubDate>Sat, 17 Oct 2020 06:00:12 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;A learning note while reading &lt;em&gt;Real-Time Collision Detection&lt;/em&gt; by Christer Ericson&lt;/p&gt;
&lt;p&gt;This is a personal blog so I’ll skip some
        
      
      </description>
      
      <content:encoded><![CDATA[<p>A learning note while reading <em>Real-Time Collision Detection</em> by Christer Ericson</p><p>This is a personal blog so I’ll skip some of the common knowledge like general 3D math or linear algebra. This intro will list some of the key concepts used in <strong>collision detection</strong> that I haven’t heard of or find important enough to re-memorize again.</p><h2 id="Polygons"><a href="#Polygons" class="headerlink" title="Polygons"></a>Polygons</h2><p>​    A <em>polygon</em> is a closed figure with <em>n</em> sides, defined by an ordered set of three or more points in the plane in such a way that each point is connected to the next (and the last to the first) with a line segment. </p><ul><li><p><strong>Simple</strong>: A polygon is <em>simple</em> if no two nonconsecutive edges have a point in common. A simple polygon partitions the plane into two disjoint parts: the <em>interior</em> (the bounded area covered by the polygon) and the <em>exterior</em> (the unbounded area outside the polygon).</p></li><li><p><strong>Convex/Concave vertex</strong>: A vertex is a convex vertex if the interior angle is less than or equal to 180 degrees. If the angle is larger than 180 degrees, it is instead called a concave (or reflex) vertex.</p><p><img src="/images/ConvexConcave.png" alt="Convex vertex and Concave vertex"></p></li><li><p><strong>Convex/Concave polygon</strong>: A polygon <em>P</em> is a convex polygon if all line segments between any two points of <em>P</em> lie fully inside <em>P</em>. A polygon that is not convex is called a concave polygon. A polygon with one or more concave vertices is necessarily concave, but a polygon with only convex vertices is not always convex.</p></li><li><p><strong>Convex hull</strong>: A convex point set $S$ is a set of points wherein the line segment between any two points in $S$ is also in $S$. Given a point set $S$, the convex hull of $S$, denoted $CH(S)$, is the smallest convex point set fully containing $S$. $CH(S)$ can also be described as the intersection of all convex point sets containing $S$. </p><p><img src="/images/ConvexHull.png" alt="Convex Hull"></p></li><li><p><strong>Affine hull</strong>: Related to the convex hull is the affine hull, $AH(S)$. The affine hull is the lowest dimensional hyperplane that contains all points of $S$. That is, if $S$ contains just one point, $AH(S)$ is the point; if $S$ contains two points, $AH(S)$ is the line through them; if $S$ contains three noncollinear points, $AH(S)$ is the plane determined by them; and if $S$ contains four (or more) non co-planar points, $AH(S)$ is all of $\mathbb{R}^3$.</p></li></ul><h3 id="Test-Polygon-Convexity"><a href="#Test-Polygon-Convexity" class="headerlink" title="Test Polygon Convexity"></a>Test Polygon Convexity</h3><h2 id="Polyhedra"><a href="#Polyhedra" class="headerlink" title="Polyhedra"></a>Polyhedra</h2><h2 id="Voronoi-Diagram"><a href="#Voronoi-Diagram" class="headerlink" title="Voronoi Diagram"></a>Voronoi Diagram</h2><p>The Voronoi diagram is named after Georgy Voronoy, and is also called a <strong>Voronoi tessellation</strong>, a <strong>Voronoi decomposition</strong>, a <strong>Voronoi partition</strong>, or a <strong>Dirichlet tessellation</strong>. Voronoi cells are also known as <strong>Thiessen polygons</strong>.</p><script type="math/tex; mode=display">R_{k}=\{x\in X\mid d(x,P_{k})\leq d(x,P_{j})\;{\text{for all}}\;j\neq k\}</script><h2 id="Minkowski-Sum-and-Difference"><a href="#Minkowski-Sum-and-Difference" class="headerlink" title="Minkowski Sum and Difference"></a>Minkowski Sum and Difference</h2><h3 id="Minkowski-Sum"><a href="#Minkowski-Sum" class="headerlink" title="Minkowski Sum"></a>Minkowski Sum</h3><p>​    Let $A$ and $B$ be two point sets, and let $\mathbf{a}$ and $\mathbf{b}$ be the position vectors corresponding to pairs of points in $A$ and $B$. The Minkowski sum, $A \oplus B$, is then defined as the set</p><script type="math/tex; mode=display">A \oplus B=\{\mathbf {a} + \mathbf {b} \,|\,\mathbf {a} \in A,\ \mathbf {b} \in B\}</script><p>where $\mathbf {a} + \mathbf {b}$ is the vector sum of the position vectors $\mathbf{a}$ and $\mathbf{b}$. </p><p><img src="/images/MinkowskiSum.png" alt="Minkowski Sum Example"></p><h3 id="Minkowski-Difference"><a href="#Minkowski-Difference" class="headerlink" title="Minkowski Difference"></a>Minkowski Difference</h3><p>​    The Minkowski difference of two point sets $A$ and $B$ is defined analogously to the Minkowski sum:</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}A \ominus B &= \{\mathbf {a} - \mathbf {b} \,|\,\mathbf {a} \in A,\ \mathbf {b} \in B\}\\&= A \oplus (-B) \end{aligned}\end{equation}</script><p>​    The Minkowski difference is important from a collision detection perspective because two point sets $A$ and $B$ collide (that is, have one or more points in common) <strong>if and only if</strong> their Minkowski difference $C (C = A \ominus B)$ contains the origin:</p><p><img src="/images/MinkowskiDiff.png" alt="Minkowski Diff Example"></p><p>​    In fact, it is possible to establish an even stronger result: computing the minimum distance between A and B is equivalent to computing the minimum distance between C and the origin. This fact is utilized in the GJK algorithm:</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}distance(A, B) &= min\left\{ \| \mathbf{a} - \mathbf{b} \| \,:\,\mathbf {a} \in A,\, \mathbf {b} \in B\ \right\}\\&= min\left\{ \| \mathbf{c} \| \,:\,\mathbf {c} \in A \ominus B \right\}\end{aligned}\end{equation}</script>]]></content:encoded>
      
      <comments>https://suncio.me/2020/10/16/Real-Time-Collision-Detection-Intro/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Physical Simulation: Smoothed Particle Hydrodynamics</title>
      <link>https://suncio.me/2020/10/06/Physical-Simulation-Smoothed-Particle-Hydrodynamics/</link>
      <guid>https://suncio.me/2020/10/06/Physical-Simulation-Smoothed-Particle-Hydrodynamics/</guid>
      <pubDate>Wed, 07 Oct 2020 03:02:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Lagrange-fluid-simulation-Smoothed-particle-hydrodynamics&quot;&gt;&lt;a href=&quot;#Lagrange-fluid-simulation-Smoothed-particle-hydrodynamics&quot; clas
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Lagrange-fluid-simulation-Smoothed-particle-hydrodynamics"><a href="#Lagrange-fluid-simulation-Smoothed-particle-hydrodynamics" class="headerlink" title="Lagrange fluid simulation: Smoothed particle hydrodynamics"></a>Lagrange fluid simulation: Smoothed particle hydrodynamics</h2><p><strong>High-level idea:</strong> use particle carrying samples of physical quantities, and a kernel function $W$, to approximate continuous fields:</p><script type="math/tex; mode=display">A(\textbf{x}) = \sum_{i}{A_i\frac{m_i}{\rho_i}W\left( ||\textbf{x} - \textbf{x}_j||_2, h \right)}</script><p><img src="/images/SPHInterpolationColorsVerbose.svg.png" alt="SPH particles and their kernel"></p><ul><li>Originally proposed for astrophysical problems</li><li>No meshes. Very suitable for free-surface flows!</li><li>Easy to understand intuitively: just imagine each particle is a small parcel of water (although strictly not the case)</li></ul><h2 id="Implementing-SPH-using-the-Equation-of-States-EOS"><a href="#Implementing-SPH-using-the-Equation-of-States-EOS" class="headerlink" title="Implementing SPH using the Equation of States (EOS)"></a>Implementing SPH using the Equation of States (EOS)</h2><p>Also know as Weakly Compressible SPH (WCSPH).</p><p>Momentum equation: ($\rho$: density; $B$: bulk modulus; $\gamma$: constant, usually $\sim 7$ )</p><script type="math/tex; mode=display">\frac{D\textbf{v}}{Dt} = -\frac{1}{\rho} \nabla p + \textbf{g},\ \ \ p = B\left( \left( \frac{\rho}{\rho_0} \right)^{\gamma} - 1 \right)\\\ \\\\\A(\textbf{x}) = \sum_{i}{A_i\frac{m_i}{\rho_i}W\left( ||\textbf{x} - \textbf{x}_j||_2, h \right)},\ \ \ \rho_i= \sum_j{ m_j W \left( ||\textbf{x} - \textbf{x}_j||_2, h \right)}</script><h2 id="Gradients-in-SPH"><a href="#Gradients-in-SPH" class="headerlink" title="Gradients in SPH"></a>Gradients in SPH</h2><script type="math/tex; mode=display">A(\textbf{x}) = \sum_{i}{A_i\frac{m_i}{\rho_i}W\left( ||\textbf{x} - \textbf{x}_j||_2, h \right)}\\\\\\nabla A_i = \rho_i \sum_{j} m_j \left( \frac{A_i}{\rho_i^2} + \frac{A_j}{\rho_j^2} \right) \nabla_{\textbf{x}_i} W\left( ||\textbf{x} - \textbf{x}_j||_2, h \right)</script><ul><li>Not really accurate</li><li>But at least symmetric and momentum conversing</li></ul><p>Now we can compute $\nabla p_i$</p><h2 id="SPH-Simulation-Cycle"><a href="#SPH-Simulation-Cycle" class="headerlink" title="SPH Simulation Cycle"></a>SPH Simulation Cycle</h2><ol><li><p>For each particle $i$, compute $\rho_i= \sum_j{ m_j W \left( ||\textbf{x} - \textbf{x}_j||_2, h \right)}$</p></li><li><p>For each particle $i$, compute $\nabla p_i$ using the gradient operator</p></li><li><p>Symplectic Euler step:</p><script type="math/tex; mode=display">\textbf{v}_{t+1} = \textbf{v}_t + \Delta t \frac{D\textbf{v}}{Dt}\\\textbf{x}_{t+1} = \textbf{x}_t + \Delta t \textbf{v}_{t+1}\</script></li></ol><p><strong>Variants of SPH</strong></p><h2 id="Courant-Friedrichs-Lewy-CFL-condition"><a href="#Courant-Friedrichs-Lewy-CFL-condition" class="headerlink" title="Courant-Friedrichs-Lewy (CFL) condition"></a>Courant-Friedrichs-Lewy (CFL) condition</h2><p>One upper bound of time step size:</p><script type="math/tex; mode=display">C = \frac{u \Delta t}{\Delta x} \le C_{max} \sim 1</script><ul><li>$C$: CFL number (Courant number, or simple the CFL)</li><li>$\Delta t$: time step</li><li>$\Delta x$: length interval (e.g. particle radius and grid size)</li><li>$u$: maximum (velocity)</li></ul><p>Application: estimating allowed time step in (explicit) time integrations. Typical $C_{max}$ in graphics:</p><ul><li>SPH: ~ 0.4</li><li>MPM: 0.3 ~ 1</li><li>FLIP fluid (smoke): 1 ~ 5+</li></ul><h2 id="Accelerating-SPH-Neighborhood-search"><a href="#Accelerating-SPH-Neighborhood-search" class="headerlink" title="Accelerating SPH: Neighborhood search"></a>Accelerating SPH: Neighborhood search</h2><p>So far, per sub-step complexity of SPH is $O(n^2)$. This is too costly to be practical. In practice, people build spatial data structure such as voxel grid to accelerate neighborhood search. This reduces time complexity to $O(n)$.</p><p>Reference: <a href="https://github.com/InteractiveComputerGraphics/CompactNSearch" target="_blank" rel="external">Compact Hashing</a></p><h2 id="Extend-reading"><a href="#Extend-reading" class="headerlink" title="Extend reading"></a>Extend reading</h2><p>SPH Fluids in Computer Graphics: <a href="https://cg.informatik.uni-freiburg.de/publications/2014_EG_SPH_STAR.pdf" target="_blank" rel="external">https://cg.informatik.uni-freiburg.de/publications/2014_EG_SPH_STAR.pdf</a></p><p>A tutorial for SPH: <a href="https://interactivecomputergraphics.github.io/SPH-Tutorial/" target="_blank" rel="external">Smoothed Particle Hydrodynamics Techniques for the Physics Based Simulation of Fluids and Solids</a></p>]]></content:encoded>
      
      <comments>https://suncio.me/2020/10/06/Physical-Simulation-Smoothed-Particle-Hydrodynamics/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Physical Simulation: Mass-Spring Systems</title>
      <link>https://suncio.me/2020/10/05/Physical-Simulation-Mass-Spring-Systems/</link>
      <guid>https://suncio.me/2020/10/05/Physical-Simulation-Mass-Spring-Systems/</guid>
      <pubDate>Tue, 06 Oct 2020 02:58:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;This a learning note from the &lt;a href=&quot;https://forum.taichi.graphics/t/topic/272&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;class&lt;/a&gt; given by Yuanm
        
      
      </description>
      
      <content:encoded><![CDATA[<p>This a learning note from the <a href="https://forum.taichi.graphics/t/topic/272" target="_blank" rel="external">class</a> given by Yuanming Hu about <strong>Physical Simulation</strong></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>Two Views of Continuums</strong></p><p>There are two basic methods for solving fluid equations</p><ul><li><p>Lagrangian View: “What are my position and velocity?” </p><p>- Method based on particles</p><p><img src="/images/lagrange.gif" alt="lagrange view"></p></li><li><p>Eulerian View: “What is the material velocity passing by?” </p><p>- Method based on grid</p><p><img src="/images/eulerian.gif" alt="eulerian view"></p></li></ul><h2 id="Mass-Spring-Systems"><a href="#Mass-Spring-Systems" class="headerlink" title="Mass-Spring Systems"></a>Mass-Spring Systems</h2><p>Mass Spring Systems are a physical simulation based on Lagrangian view, an object are seen as  . Mass-spring systems are good for  </p><p><strong>Hooke’s Law</strong></p><script type="math/tex; mode=display">\textbf{f}_{ij} = -k(||\textbf{x}_i - \textbf{x}_j||_2-l_{ij})(\widehat{\textbf{x}_i-\textbf{x}_j})\\\ \\\textbf{f}_i = \sum_{j}^{j \ne i}{\textbf{f}_{ij}}</script><p><strong>Newton’s second law of motion</strong></p><script type="math/tex; mode=display">\frac{\partial \textbf{v}_i}{\partial t} = \frac{1}{m}\textbf{f}_i\\\ \\\frac{\partial \textbf{x}_i}{\partial t} = \textbf{v}_i</script><h2 id="Time-integration"><a href="#Time-integration" class="headerlink" title="Time integration"></a>Time integration</h2><p><strong>Time integration - Explicit</strong></p><p>(1) Forward Euler (explicit)</p><script type="math/tex; mode=display">\textbf{v}_{t+1} = \textbf{v}_t + \Delta t \frac{\textbf{f}_t}{m}\\\textbf{x}_{t+1} = \textbf{x}_t + \Delta t \textbf{v}_t</script><p>(2) Semi implicit Euler (aka. symplectic Euler, explicit)</p><script type="math/tex; mode=display">\textbf{v}_{t+1} = \textbf{v}_t + \Delta t \frac{\textbf{f}_t}{m}\\\textbf{x}_{t+1} = \textbf{x}_t + \Delta t \textbf{v}_{t+1}</script><div class="table-container"><table><thead><tr><th>Pros</th><th>Cons</th></tr></thead><tbody><tr><td>Future depends only on past</td><td>Easy to explode</td></tr><tr><td>Easy to implement</td><td>Bad for stiff materials</td></tr></tbody></table></div><p>Explosion limit:</p><script type="math/tex; mode=display">\Delta t \le c \sqrt{\frac{m}{k}} (c \sim 1)</script><p><strong>Time integration - Implicit</strong></p><p>Backward Euler (often with Newton’s method, implicit)</p><script type="math/tex; mode=display">\textbf{x}_{t+1} = \textbf{x}_t + \Delta t \textbf{v}_{t+1}\\\textbf{v}_{t+1} = \textbf{v}_t + \Delta t \textbf{M}^{-1}\textbf{f}(\textbf{x}_{t+1})</script><p>Estimate $\textbf{x}_{t+1}$:</p><script type="math/tex; mode=display">\textbf{v}_{t+1} = \textbf{v}_t + \Delta t \textbf{M}^{-1}\textbf{f}(\textbf{x}_{t} + \Delta t \textbf{v}_{t+1})</script><p>Linearize (one step of Newton’s method):</p><script type="math/tex; mode=display">\textbf{v}_{t+1} = \textbf{v}_t + \Delta t \textbf{M}^{-1}    \left[\textbf{f}(\textbf{x}_{t}) + \frac{\partial \textbf{f}}{\partial \textbf{x}} (\textbf{x}_{t}) \Delta t \textbf{v}_{t+1}    \right]</script><p>Clean up:</p><script type="math/tex; mode=display">\left[\textbf{I} - \Delta t^2 \textbf{M}^{-1} \frac{\partial \textbf{f}}{\partial \textbf{x}} (\textbf{x}_{t})     \right] \textbf{v}_{t+1} = \textbf{v}_t + \Delta t \textbf{M}^{-1}\textbf{f}(\textbf{x}_{t})</script><p>How to solve it</p><ul><li>Jacobi/Gauss-Seidel iterations (easy to implement)</li><li>Conjugate gradients </li></ul><p><strong>Unify explicit and implicit integrators</strong></p><script type="math/tex; mode=display">\left[\textbf{I} - \beta \Delta t^2 \textbf{M}^{-1} \frac{\partial \textbf{f}}{\partial \textbf{x}} (\textbf{x}_{t})   \right] \textbf{v}_{t+1} = \textbf{v}_t + \Delta t \textbf{M}^{-1}\textbf{f}(\textbf{x}_{t})</script><ul><li>$\beta = 0$: forward/semi-implicit Euler (explicit)</li><li>$\beta = 1/2$: middle-point (implicit)</li><li>$\beta = 1$: backward Euler (implicit)</li></ul><p><strong>Solve faster</strong></p><ul><li>Sparse matrices</li><li>Conjugate gradients</li><li>Preconditioning</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>Based on Mass-Spring System, I wrote a simple rope simulator using OpenGL. I choose semi implicit time integration as it’s the most intuitive method without revolving other math libs dependency. </p><p>Source repo is <a href="https://github.com/suncio/OpenGL-Learning" target="_blank" rel="external">here</a></p><p><img src="/images/RopeSimulator.gif" alt="Rope Simulator"></p>]]></content:encoded>
      
      <comments>https://suncio.me/2020/10/05/Physical-Simulation-Mass-Spring-Systems/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Ray Tracing: Getting Started</title>
      <link>https://suncio.me/2020/09/13/Ray-Tracing-Getting-Started/</link>
      <guid>https://suncio.me/2020/09/13/Ray-Tracing-Getting-Started/</guid>
      <pubDate>Mon, 14 Sep 2020 04:05:36 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/FirstFinalScene.png&quot; alt=&quot;First Final Scene&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overv
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="/images/FirstFinalScene.png" alt="First Final Scene"></p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>From <a href="http://www.pbr-book.org/3ed-2018/Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html" target="_blank" rel="external">pbrt</a> I quote:</p><blockquote><p>Although there are many ways to write a ray tracer, all such systems simulate at least the following objects and phenomena:</p><ul><li><em>Cameras:</em> …</li><li><em>Ray–object intersections:</em> …</li><li><em>Light sources:</em> …</li><li><em>Visibility:</em> …</li><li><em>Surface scattering:</em> …</li><li><em>Indirect light transport:</em> …</li><li><em>Ray propagation:</em> …</li></ul></blockquote><p>As shown in the diagram below, from the camera we shoot a <strong>view ray</strong> towards every pixel in image space and track how they interact with objects/lights in the scene. And finally we have a color value for every single pixel. </p><p><img src="/images/RayTraceDiagram.svg" alt="ray trace overview"></p><p>Personally I learned rasterization before learning ray tracing, internally they have opposite philosophy: from the world to your eye or how your eye sees the world. And compare to all the approximation and interpolation method we use in <strong>rasterization</strong>, <strong>ray tracing</strong> is a more intuitive, realistic and yet resource consuming way for image rendering. </p><h2 id="Ray"><a href="#Ray" class="headerlink" title="Ray"></a>Ray</h2><p>Since it’s called ray-tracing, obviously we need to represent a ray. A ray is denoted by formula</p><script type="math/tex; mode=display">\mathbf{P}(t) = \mathbf{origin} + t * \mathbf{direction}</script><p>Accordingly we have a <code>Ray</code> class</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ray</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="comment">// ctor/dtor</span></div><div class="line">Ray() = <span class="keyword">default</span>;</div><div class="line">~Ray() = <span class="keyword">default</span>;</div><div class="line">Ray(<span class="keyword">const</span> Vector3&amp; org, <span class="keyword">const</span> Vector3&amp; dir, <span class="keyword">double</span> time = <span class="number">0.0</span>)</div><div class="line">: m_origin(org), m_direction(dir), m_time(time)</div><div class="line">&#123;</div><div class="line">m_direction.normalize();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Getter</span></div><div class="line"><span class="function">Vector3 <span class="title">getOrigin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_origin; &#125;</div><div class="line"><span class="function">Vector3 <span class="title">getDirection</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_direction; &#125;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">getTime</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_time; &#125;</div><div class="line"></div><div class="line"><span class="comment">// p(t) = origin + t * dir;</span></div><div class="line"><span class="function">Vector3 <span class="title">pointAt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; t)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_origin + m_direction * t; &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">Vector3 m_origin;</div><div class="line">Vector3 m_direction;</div><div class="line"><span class="keyword">double</span> m_time;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h2><p>Contrary to rasterization, most of the operations we have is in world space, thus we need to transform screen space pixel coordinates into world space and shoot a view ray accordingly. </p><p>$u, w, v$ represents axes of camera space, which is also right-hand. Then <code>vfov</code> and <code>aspect_ratio</code>  determines the view frustum. Then we have a <code>Camera</code> class:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">Camera(</div><div class="line">Point3  lookfrom,</div><div class="line">Point3  lookat,</div><div class="line">Vector3 vup,</div><div class="line"><span class="keyword">double</span>  vfov,  <span class="comment">// vertical field-of-view in degrees</span></div><div class="line"><span class="keyword">double</span>  aspect_ratio,</div><div class="line"><span class="keyword">double</span>  aperture,</div><div class="line"><span class="keyword">double</span>  focus_dist,</div><div class="line"><span class="keyword">double</span> t0 = <span class="number">0</span>, </div><div class="line"><span class="keyword">double</span> t1 = <span class="number">0</span></div><div class="line">)</div><div class="line">&#123;</div><div class="line"><span class="keyword">auto</span> theta = degreeToRadian(vfov);</div><div class="line"><span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2.0</span>);</div><div class="line"><span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</div><div class="line"><span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</div><div class="line"></div><div class="line">w = (lookfrom - lookat).getNormalied();</div><div class="line">u = vup.crossProduct(w).getNormalied();</div><div class="line">v = w.crossProduct(u).getNormalied();</div><div class="line"></div><div class="line">m_origin = lookfrom;</div><div class="line">m_horizontal = focus_dist * viewport_width * u;</div><div class="line">m_vertical = focus_dist * viewport_height * v;</div><div class="line">m_lowerLeftCorner = m_origin - m_horizontal / <span class="number">2.0</span> - m_vertical / <span class="number">2.0</span> - focus_dist * w;</div><div class="line"></div><div class="line">m_lens_radius = aperture / <span class="number">2</span>;</div><div class="line">m_time0 = t0;</div><div class="line">m_time1 = t1;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Ray <span class="title">getRay</span><span class="params">(<span class="keyword">double</span> s, <span class="keyword">double</span> t)</span> <span class="keyword">const</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">Vector3 rd = m_lens_radius * Vector3::randomInUnitDisk();</div><div class="line">Vector3 offset = u * rd.x + v * rd.y;</div><div class="line"><span class="keyword">return</span> Ray(</div><div class="line">m_origin + offset,</div><div class="line">m_lowerLeftCorner + s * m_horizontal + t * m_vertical - m_origin - offset,</div><div class="line">random_double(m_time0, m_time1)</div><div class="line">);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">Point3 m_origin;</div><div class="line">Point3 m_lowerLeftCorner;</div><div class="line">Vector3 m_horizontal;</div><div class="line">Vector3 m_vertical;</div><div class="line">Vector3 u, v, w;</div><div class="line"><span class="keyword">double</span> m_lens_radius;</div><div class="line"><span class="keyword">double</span> m_time0, m_time1; <span class="comment">// shutter open/close time</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="Ray-Object-Intersections"><a href="#Ray-Object-Intersections" class="headerlink" title="Ray-Object Intersections"></a>Ray-Object Intersections</h2><h3 id="Base-class"><a href="#Base-class" class="headerlink" title="Base class"></a>Base class</h3><p>We create a <code>HitRecord</code> struct to keep record of the hit information we need. And a virtual base class for other objects that can be hit.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Material</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HitRecord</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">Point3 position;</div><div class="line">Vector3 normal;</div><div class="line"><span class="built_in">shared_ptr</span>&lt;Material&gt; mat_ptr;</div><div class="line"><span class="keyword">double</span> t;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hittable</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">Hittable() = <span class="keyword">default</span>;</div><div class="line"><span class="keyword">virtual</span> ~Hittable() = <span class="keyword">default</span>;</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> Ray&amp; r, <span class="keyword">const</span> <span class="keyword">double</span>&amp; t_min, <span class="keyword">const</span> <span class="keyword">double</span>&amp; t_max, HitRecord&amp; rec)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="Sphere"><a href="#Sphere" class="headerlink" title="Sphere"></a>Sphere</h3><p>For now we only have one primitive geometry - sphere, which make the  intersection math very simple, we know a sphere is denoted by formula:</p><script type="math/tex; mode=display">(x-\mathbf{c}.x)^2 + (y-\mathbf{c}.y)^2 + (z-\mathbf{c}.z)^2 = R^2</script><p>And we put $\mathbf{P} = \mathbf{P}(t) = \mathbf{O} + t\mathbf{D}$ into the equation:</p><script type="math/tex; mode=display">(\mathbf{D} \cdot \mathbf{D})t^2 + 2(\mathbf{D} \cdot (\mathbf{S} - \mathbf{c}))t + (\mathbf{S} - \mathbf{c}) \cdot (\mathbf{S} - \mathbf{c}) - R^2 = 0</script><p>For $at^2 + bt + c = 0$ we have</p><script type="math/tex; mode=display">t = \frac{-b\pm \sqrt{b^2-4ac}}{2a}</script><p>where $b^2−4ac$ is the <strong>discriminant</strong> of the equation, and</p><ul><li>If $discriminant&lt;0$, the line of the ray does not intersect the sphere (missed);</li><li>If $discriminant=0$, the line of the ray just touches the sphere in one point (tangent);</li><li>If $discriminant&gt;0$, the line of the ray touches the sphere in two points (intersected).</li></ul><p>Then we have the <code>Sphere</code> class</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sphere</span> :</span> <span class="keyword">public</span> Hittable</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">Sphere()&#123;&#125;</div><div class="line">Sphere(Point3 center, <span class="keyword">double</span> r, <span class="built_in">shared_ptr</span>&lt;Material&gt; m) : m_center(center), m_radius(r), m_mat_ptr(m) &#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> Ray&amp; r, <span class="keyword">const</span> <span class="keyword">double</span>&amp; tmin, <span class="keyword">const</span> <span class="keyword">double</span>&amp; tmax, HitRecord&amp; rec)</span> <span class="keyword">const</span> override</span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">Point3 m_center;</div><div class="line"><span class="keyword">double</span> m_radius;</div><div class="line"><span class="built_in">shared_ptr</span>&lt;Material&gt; m_mat_ptr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> Sphere::hit(<span class="keyword">const</span> Ray &amp;r, <span class="keyword">const</span> <span class="keyword">double</span> &amp;tmin, <span class="keyword">const</span> <span class="keyword">double</span> &amp;tmax, HitRecord &amp;rec) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">Vector3 oc = r.getOrigin() - m_center;</div><div class="line"><span class="keyword">double</span> a = r.getDirection().getSquaredLength();</div><div class="line"><span class="keyword">double</span> half_b = oc.dotProduct(r.getDirection());</div><div class="line"><span class="keyword">double</span> c = oc.getSquaredLength() - m_radius * m_radius;</div><div class="line"><span class="keyword">double</span> discriminant = half_b * half_b - a * c;</div><div class="line"><span class="keyword">if</span> (discriminant &gt; <span class="number">0.0</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">double</span> tmp = (-half_b - <span class="built_in">sqrt</span>(discriminant)) / a;</div><div class="line"><span class="keyword">if</span> (tmp &gt; tmin &amp;&amp; tmp &lt; tmax)</div><div class="line">&#123;</div><div class="line">rec.t = tmp;</div><div class="line">rec.position = r.pointAt(rec.t);</div><div class="line">Vector3 outward_normal = (rec.position - m_center) / m_radius;</div><div class="line">rec.setFaceNormal(r, outward_normal);</div><div class="line">Sphere::getSphereUV((rec.position - m_center) / m_radius, rec.u, rec.v);</div><div class="line">rec.mat_ptr = m_mat_ptr;</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">tmp = (-half_b + <span class="built_in">sqrt</span>(discriminant)) / a;</div><div class="line"><span class="keyword">if</span> (tmp &gt; tmin &amp;&amp; tmp &lt; tmax)</div><div class="line">&#123;</div><div class="line">rec.t = tmp;</div><div class="line">rec.position = r.pointAt(rec.t);</div><div class="line">Vector3 outward_normal = (rec.position - m_center) / m_radius;</div><div class="line">rec.setFaceNormal(r, outward_normal);</div><div class="line">Sphere::getSphereUV((rec.position - m_center) / m_radius, rec.u, rec.v);</div><div class="line">rec.mat_ptr = m_mat_ptr;</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="List-of-hittable-objects"><a href="#List-of-hittable-objects" class="headerlink" title="List of hittable objects"></a>List of hittable objects</h3><p>For multiple objects in the scene we can have a list of these objects as it’s one giant object.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HittableList</span> :</span> <span class="keyword">public</span> Hittable</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">HittableList() = <span class="keyword">default</span>;</div><div class="line">HittableList(<span class="built_in">shared_ptr</span>&lt;Hittable&gt; object) &#123; add(object); &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; m_list.clear(); &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Hittable&gt; object)</span> </span>&#123; m_list.push_back(object); &#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_list.empty(); &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> Ray&amp; r, <span class="keyword">const</span> <span class="keyword">double</span>&amp; tmin, <span class="keyword">const</span> <span class="keyword">double</span>&amp; tmax, HitRecord&amp; rec)</span> <span class="keyword">const</span> override</span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Hittable&gt;&gt; m_list;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> HittableList::hit(<span class="keyword">const</span> Ray &amp;r, <span class="keyword">const</span> <span class="keyword">double</span> &amp;tmin, <span class="keyword">const</span> <span class="keyword">double</span> &amp;tmax, HitRecord &amp;rec) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">HitRecord temp_rec;</div><div class="line"><span class="keyword">bool</span> hit_anything = <span class="literal">false</span>;</div><div class="line"><span class="keyword">double</span> closest_so_far = tmax;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_list.size(); i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (m_list[i]-&gt;hit(r, tmin, closest_so_far, temp_rec))</div><div class="line">&#123;</div><div class="line">hit_anything = <span class="literal">true</span>;</div><div class="line">closest_so_far = temp_rec.t;</div><div class="line">rec = temp_rec;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> hit_anything;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h2><p>A material basically describes what an object will do to the ray when the ray hits the object - how it reflects, refracts and so on. We design a interface <code>scatter</code> to describe such behavior.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Material</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(<span class="keyword">const</span> Ray&amp; r_in, <span class="keyword">const</span> HitRecord&amp; rec, Color&amp; attenuation, Ray&amp; scattered)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="Lambertian"><a href="#Lambertian" class="headerlink" title="Lambertian"></a>Lambertian</h3><h3 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a>Metal</h3><h3 id="Dielectric"><a href="#Dielectric" class="headerlink" title="Dielectric"></a>Dielectric</h3><h2 id="Antialiasing"><a href="#Antialiasing" class="headerlink" title="Antialiasing"></a>Antialiasing</h2><p>Without antialiasing the image tend to have noisy and alias, we simply do a uniform-random sample in a square without considering the sample PDF(probability density function) :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s)</div><div class="line">&#123;</div><div class="line"><span class="keyword">auto</span> u = (i + random_double()) / (image_width - <span class="number">1</span>);</div><div class="line"><span class="keyword">auto</span> v = (j + random_double()) / (image_height - <span class="number">1</span>);</div><div class="line">Ray r = cam.getRay(u, v);</div><div class="line">pixel_color += ray_color(r, background, world, max_depth);</div><div class="line">&#125;</div><div class="line">write_color(buffer, i, j, image_width, pixel_color, samples_per_pixel);</div></pre></td></tr></table></figure><h2 id="Depth-of-Field-Defocus-Blur"><a href="#Depth-of-Field-Defocus-Blur" class="headerlink" title="Depth of Field (Defocus Blur)"></a>Depth of Field (Defocus Blur)</h2>]]></content:encoded>
      
      <comments>https://suncio.me/2020/09/13/Ray-Tracing-Getting-Started/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Ruskell &amp; Algorithms (2) -- FFT</title>
      <link>https://suncio.me/2017/12/09/Ruskell-Algorithms-2-FFT/</link>
      <guid>https://suncio.me/2017/12/09/Ruskell-Algorithms-2-FFT/</guid>
      <pubDate>Sun, 10 Dec 2017 07:27:43 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;这是一个利用Rust&amp;amp;Haskell实现算法导论上的经典算法或其他有趣算法的系列，代码可以点击此&lt;a href=&quot;https://play.rust-lang.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线运行&lt;/a&gt;得到结果，你可能
        
      
      </description>
      
      <content:encoded><![CDATA[<p>这是一个利用Rust&amp;Haskell实现算法导论上的经典算法或其他有趣算法的系列，代码可以点击此<a href="https://play.rust-lang.org/" target="_blank" rel="external">在线运行</a>得到结果，你可能需要补充合理的输入输出与main函数。<br>第二篇是实现FFT与普通多项式乘法，下面是相应的Rust代码：</p><p>首先是FFT算法<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dft</span></span>(src: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;Complex&lt;<span class="built_in">f64</span>&gt;&gt;, flag: <span class="built_in">bool</span>) &#123;</div><div class="line"><span class="comment">// src 的长度为 2 的幂； flag 为 false 时计算 DFT， 为 true 时计算逆 DFT</span></div><div class="line"><span class="keyword">let</span> len = src.len();</div><div class="line"><span class="keyword">let</span> s = len.trailing_zeros();</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..len &#123;</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> k = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..s &#123;</div><div class="line">k |= ((i &gt;&gt; j) &amp; <span class="number">1</span>) &lt;&lt; (s - <span class="number">1</span> - j);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> i &lt; k &#123;</div><div class="line">src.swap(i, k);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..s &#123;</div><div class="line"><span class="keyword">let</span> base = (<span class="number">2</span> &lt;&lt; i) <span class="keyword">as</span> <span class="built_in">usize</span>;</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> j = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> j &lt; len &#123;</div><div class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">0</span>..(base / <span class="number">2</span>) &#123;</div><div class="line"><span class="keyword">let</span> w = <span class="keyword">if</span> flag &#123;</div><div class="line">Complex::from_polar(&amp;<span class="number">1.0</span>, &amp;(-<span class="number">2.0</span> * <span class="built_in">f64</span>::consts::PI * k <span class="keyword">as</span> <span class="built_in">f64</span> / base <span class="keyword">as</span> <span class="built_in">f64</span>))</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">Complex::from_polar(&amp;<span class="number">1.0</span>, &amp;(<span class="number">2.0</span> * <span class="built_in">f64</span>::consts::PI * k <span class="keyword">as</span> <span class="built_in">f64</span> / base <span class="keyword">as</span> <span class="built_in">f64</span>))</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> t = w * src[base / <span class="number">2</span> + j + k];</div><div class="line"><span class="keyword">let</span> u = src[j + k];</div><div class="line">src[j + k] = u + t;</div><div class="line">src[base / <span class="number">2</span> + j + k] = u - t;</div><div class="line">&#125;</div><div class="line">j += base;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> flag &#123;</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..len &#123;</div><div class="line">src[i] = src[i] / len <span class="keyword">as</span> <span class="built_in">f64</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">poly_mult_fft</span></span>(a: &amp;[<span class="built_in">f64</span>], b: &amp;[<span class="built_in">f64</span>]) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">f64</span>&gt; &#123;</div><div class="line"><span class="keyword">let</span> len = <span class="number">1</span> &lt;&lt; (<span class="number">32</span> - ((a.len() + b.len()) <span class="keyword">as</span> <span class="built_in">i32</span>).leading_zeros());</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> aa: <span class="built_in">Vec</span>&lt;Complex&lt;<span class="built_in">f64</span>&gt;&gt; = <span class="built_in">vec!</span>[Complex &#123;re: <span class="number">0.0</span>, im: <span class="number">0.0</span>&#125;; len];</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..a.len() &#123;</div><div class="line">aa[i].re = a[i];</div><div class="line">&#125;</div><div class="line">dft(&amp;<span class="keyword">mut</span> aa, <span class="literal">false</span>);</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> bb: <span class="built_in">Vec</span>&lt;Complex&lt;<span class="built_in">f64</span>&gt;&gt; = <span class="built_in">vec!</span>[Complex &#123;re: <span class="number">0.0</span>, im: <span class="number">0.0</span>&#125;; len];</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..b.len() &#123;</div><div class="line">bb[i].re = b[i];</div><div class="line">&#125;</div><div class="line">dft(&amp;<span class="keyword">mut</span> bb, <span class="literal">false</span>);</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..len &#123;</div><div class="line">aa[i] *= bb[i];</div><div class="line">&#125;</div><div class="line">dft(&amp;<span class="keyword">mut</span> aa, <span class="literal">true</span>);</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> c = <span class="built_in">Vec</span>::new();</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..(a.len() + b.len() - <span class="number">1</span>) &#123;</div><div class="line">c.push(aa[i].re);</div><div class="line">&#125;</div><div class="line">c</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后是普通乘法<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">poly_mult_norm</span></span>(a: &amp;[<span class="built_in">f64</span>], b: &amp;[<span class="built_in">f64</span>]) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">f64</span>&gt; &#123;</div><div class="line"><span class="keyword">let</span> al = a.len();</div><div class="line"><span class="keyword">let</span> bl = b.len();</div><div class="line"><span class="keyword">let</span> cl = al + bl - <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> c = <span class="built_in">vec!</span>[<span class="number">0.0</span>; cl];</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..cl &#123;</div><div class="line"><span class="keyword">let</span> k = <span class="keyword">if</span> i + <span class="number">1</span> &lt; bl &#123; <span class="number">0</span> &#125; <span class="keyword">else</span> &#123; i + <span class="number">1</span> - bl &#125;;</div><div class="line"><span class="keyword">let</span> m = <span class="keyword">if</span> i + <span class="number">1</span> &gt; al &#123; al &#125; <span class="keyword">else</span> &#123; i + <span class="number">1</span> &#125;;</div><div class="line"><span class="keyword">for</span> j <span class="keyword">in</span> k..m &#123;</div><div class="line">c[i] += a[j] * b[i - j];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">c</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Note:</p><ol><li>需要<code>extern crate num</code>使用复数</li><li>FFT需要大约2000+的输入量才能发挥其数量级优势，否则被常数拖死，还没有普通乘法快</li></ol>]]></content:encoded>
      
      <comments>https://suncio.me/2017/12/09/Ruskell-Algorithms-2-FFT/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Ruskell &amp; Algorithms (1) -- Matrix Chain Order</title>
      <link>https://suncio.me/2017/11/29/Ruskell-Algorithms-1-Matrix-Chain-Order/</link>
      <guid>https://suncio.me/2017/11/29/Ruskell-Algorithms-1-Matrix-Chain-Order/</guid>
      <pubDate>Wed, 29 Nov 2017 18:10:12 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;这是一个利用Rust&amp;amp;Haskell实现算法导论上的经典算法或其他有趣算法的系列（大概不会坑吧），所有代码可以点击此&lt;a href=&quot;https://play.rust-lang.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线运行&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<p>这是一个利用Rust&amp;Haskell实现算法导论上的经典算法或其他有趣算法的系列（大概不会坑吧），所有代码可以点击此<a href="https://play.rust-lang.org/" target="_blank" rel="external">在线运行</a>得到结果。<br>第一篇是实现的利用动态规划解决矩阵链乘法问题的问题，下面是相应的Rust代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> time;</div><div class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> rand;</div><div class="line"></div><div class="line"><span class="keyword">use</span> time::*;</div><div class="line"><span class="keyword">use</span> std::vec;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_optimal_parens</span></span>(<span class="comment">/*file:&amp;mut File, */</span>s:&amp;<span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;&gt;, i:<span class="built_in">u32</span>, j:<span class="built_in">u32</span> ) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> i == j</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">print!</span>(<span class="string">"A&#123;&#125; "</span>, i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">print!</span>(<span class="string">"( "</span>);</div><div class="line">        print_optimal_parens(s, i, s[i <span class="keyword">as</span> <span class="built_in">usize</span>][j <span class="keyword">as</span> <span class="built_in">usize</span>]);</div><div class="line">        print_optimal_parens(s, s[i <span class="keyword">as</span> <span class="built_in">usize</span>][j <span class="keyword">as</span> <span class="built_in">usize</span>]+<span class="number">1</span>, j);</div><div class="line">        <span class="built_in">print!</span>(<span class="string">") "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">matrix_chain_order</span></span>(p:&amp;<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;) -&gt; (<span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;&gt;, <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;&gt;)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> n = p.len() - <span class="number">1</span>;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> m:<span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;&gt; = <span class="built_in">Vec</span>::with_capacity(n+<span class="number">1</span>);</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s:<span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;&gt; = <span class="built_in">Vec</span>::with_capacity(n+<span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..n+<span class="number">1</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> temp:<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">Vec</span>::with_capacity(n+<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n+<span class="number">1</span></div><div class="line">        &#123;</div><div class="line">            temp.push(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        m.push(temp);</div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> temp:<span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">Vec</span>::with_capacity(n+<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n+<span class="number">1</span></div><div class="line">        &#123;</div><div class="line">            temp.push(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        s.push(temp);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="number">2</span>..n+<span class="number">1</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..n-l+<span class="number">2</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">let</span> j:<span class="built_in">usize</span> = i+l-<span class="number">1</span>;</div><div class="line">            m[i][j] = std::<span class="built_in">u32</span>::MAX;</div><div class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> i..j</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">let</span> temp:<span class="built_in">u32</span> = p[i-<span class="number">1</span>]* p[k] * p[j];</div><div class="line">                <span class="keyword">let</span> q:<span class="built_in">u32</span> = m[i][k] + m[k+<span class="number">1</span>][j] + temp;</div><div class="line">                <span class="keyword">if</span> q &lt; m[i][j]</div><div class="line">                &#123;</div><div class="line">                    m[i][j] = q;</div><div class="line">                    s[i][j] = k <span class="keyword">as</span> <span class="built_in">u32</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (s, m)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> vec = <span class="built_in">Vec</span>::new();</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">31</span> <span class="comment">//generate n+1 (n=30) numbers</span></div><div class="line">    &#123;</div><div class="line">        vec.push(rand::random::&lt;<span class="built_in">u32</span>&gt;() % <span class="number">100</span> + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> start = time::now();</div><div class="line">    <span class="keyword">let</span> (s, m) = matrix_chain_order(&amp;vec);</div><div class="line">    </div><div class="line">    <span class="built_in">println!</span>(<span class="string">"s:"</span>);</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..s.len()</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..s[i].len()</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">print!</span>(<span class="string">"&#123;&#125;  "</span>, s[i][j]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">println!</span>(<span class="string">"  new line "</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"m:"</span>);</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..m.len()</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..m[i].len()</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">print!</span>(<span class="string">"&#123;&#125;  "</span>, m[i][j]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">println!</span>(<span class="string">"  new line  "</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">let</span> end = time::now();</div><div class="line"><span class="keyword">let</span> dura = end - start; </div><div class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, dura);  </div><div class="line">    print_optimal_parens(&amp;s, <span class="number">1</span>, s.len() <span class="keyword">as</span> <span class="built_in">u32</span> - <span class="number">1</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Note:</p><ol><li>有一个小坑是关于time的，似乎是由于实现原因，不能用占位符{}打印time，需要用debug下的{:?}来打印时间。</li><li>Rust的变量生存周期跟c系列还是挺不一样的，写的时候略微有些不习惯</li></ol>]]></content:encoded>
      
      <comments>https://suncio.me/2017/11/29/Ruskell-Algorithms-1-Matrix-Chain-Order/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
